I"I<p>Collection of random notes of mine while ramping up on the domain of SAT solvers.</p>

<h3 id="sat-solvers">SAT solvers</h3>
<ul>
  <li>DNF - Disjunctive Normal Form. Eg: <code class="language-plaintext highlighter-rouge">(x AND y) OR (y AND z)</code></li>
  <li>NNF - Negative Normal Form. All negations are only in front of variables</li>
  <li>CNF - Conjunctive Normal Form. Eg: <code class="language-plaintext highlighter-rouge">(x OR y) AND (y OR z)</code></li>
  <li>CNF formula is a set of clauses (conjunctive) which each clause being a set of
literals (disjunctive)
    <ul>
      <li>empty formula represents a true formula</li>
      <li>empty clause represents a false clause</li>
      <li>unit clause is a clause with just 1 literal</li>
      <li>variable is referred by its id</li>
      <li>positive id means the variable and negative means its negation</li>
    </ul>
  </li>
  <li>SAT is NP-complete but in practice (aka real world problems) we can do much better</li>
  <li>Serial SAT algos
    <ul>
      <li>complete algos (aka systematic solvers)
        <ul>
          <li>Typically based on backtracking</li>
          <li>eg: DPLL, GRASP</li>
          <li>computationally expensive</li>
          <li>will return all satisfying assignments if they exist</li>
          <li>else will give proof for unsatisfiability</li>
        </ul>
      </li>
      <li>incomplete algos
        <ul>
          <li>eg: randomized algos, local search based, GSAT, WalkSAT</li>
          <li>may or may not produce SAT/UNSAT</li>
          <li>these local search strategies do often reach global minima!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Parallel algos
    <ul>
      <li>partioning based</li>
      <li>competition based</li>
    </ul>
  </li>
  <li>DPLL
    <ul>
      <li>complete solver based on backtracking</li>
      <li>most of the complete solvers are all mostly based on this algo</li>
      <li>if it is a unit clause then assign it to true</li>
      <li>repeat until no more unit clauses</li>
      <li>if a conflict is found, backtrack and assign a different value to that literal</li>
    </ul>
  </li>
  <li>GRASP
    <ul>
      <li>improvement over DPLL with learning clauses to reduce the amount of backtracking</li>
      <li>uses CDCL - Conflict Driven Clause Learning</li>
      <li>helps narrows search space with DPLL</li>
    </ul>
  </li>
  <li>k-CNF = formulat with every clause having exactly ‘k’ literals</li>
  <li>2-CNF formulae can be solved in poly-time, whereas 3-CNF is already NP-complete</li>
  <li>to reduce memory usage most solvers nowadays are iterative rather than recursive</li>
  <li>GSAT
    <ul>
      <li>randomized local search technique</li>
      <li>selects assignments which most reduces the number of remaining clauses</li>
      <li>can also move sideways (aka plateaus) which doesn’t reduce this at all!</li>
    </ul>
  </li>
  <li>WalkSAT
    <ul>
      <li>interleaves greedy moves of GSAT with random walks of a Metropolis search</li>
    </ul>
  </li>
  <li>m = #of clauses, n = #of variables, for k-CNF problems, if clauses are generated
randomly, then the hardness of these problems (aka number of DP calls) follows
an easy-hard-easy pattern as a function of \(\frac{m}{n}\). But when we don’t
consider fixed length clauses then there are no such clean indication of hardness!</li>
  <li>the above was the main reason which motivated local search methods for SAT solvers</li>
  <li>SP - Survey Propagation. Use of probabilistic reasoning for solving combinatorial
search problems. But SP is currently limited only for random SAT instances!</li>
  <li>Max-SAT
    <ul>
      <li>Maximum satisfiability problem</li>
      <li>return the maximum number of clauses that can be satisfied by the assignments</li>
      <li>it is a generalization of the SAT problem</li>
    </ul>
  </li>
  <li>Nice (4hrs!) talk on implementing a SAT solver from scratch
    <ul>
      <li>video: https://www.youtube.com/watch?v=II2RhzwYszQ</li>
      <li>repo: https://github.com/arminbiere/satch (It is a from-scratch serial solver
based on CDCL with restarting mechanism)</li>
      <li>initial hour or so talks about the theory/background introducing popular
solvers (eg: DPLL, CDCL)</li>
      <li>Stopped at 1:05:15</li>
    </ul>
  </li>
  <li>The Armin Biere’s talk on SAT solving: https://www.youtube.com/watch?v=Emhg0uZnbNg
    <ul>
      <li>Knuth himself acknowledged SAT solving to be the “killer app”!</li>
      <li>AIG - And-Inverter Gates. Logical gates built using only and and nor gates</li>
      <li>IPASIR model showing different states of a SAT solver: (UNKNOWN, SAT,
UNSAT, SOLVING), for interactive solving of formulae</li>
      <li>In one of his videos, the CTO of Amazon spends 20mins talking about SMT solvers!</li>
      <li>SMT solvers completely rely on CDCL technique</li>
      <li>after constructing impllication graph, typically we would like to learn the
clause out of its first UIP (Unique Implication Point) and then to recursive
clause minimization</li>
      <li>in his satch codebase this recursive clause minimization code when expressed in
recursive fashion is running faster than the iterative version!</li>
    </ul>
  </li>
  <li>Peek inside SAT solvers: https://www.youtube.com/watch?v=d76e4hV1iJY
    <ul>
      <li>introduction to the SAT problem and CNF notation</li>
      <li>typical flow: high-level problem -&gt; encode into SAT using a P-time algo -&gt; use SAT solver</li>
      <li>introduces the DFS based search space to solving this brute-force</li>
      <li>but also notes that we are free to choose assignment as well as literal
order in this DFS!</li>
      <li>shows the benefit of simplifying the clause evaluation through unit propagation</li>
      <li>thereby deriving DPLL (DFS + backtrack + unit-prop)</li>
      <li>zChaff solver
        <ul>
          <li>VSIDS - ranking the literals based on their occurence count and then using
this to assign values in order to reach solution faster</li>
          <li>two watched literals - have an index of pair of literals to reach its
clauses faster, especially to be notified when we get unit-prop</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>CDCL - GRASP solver
    <ul>
      <li>when conflicts arise, create an implication graph, separate the literals from
the conflicts and then derive the clause that can help us not revisit this
conflict during future traversals</li>
      <li>then depending on the clauses we could also backjump multiple levels!</li>
      <li>however one needs to consider the following while learning such clauses:
        <ul>
          <li>we simply can’t keep learning all the clauses (space issues)</li>
          <li>need to maintain these clauses in a clever manner</li>
          <li>need to minimize these clauses using a technique called “resolution”</li>
          <li>need to save the last assignment to variables called “phase saving”</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>restarts
    <ul>
      <li>we are not clearing the learned clauses, but only restarting the DFS</li>
      <li>can help us get unstuck at times</li>
    </ul>
  </li>
</ul>

<h3 id="sat-benchmarks">SAT Benchmarks</h3>
<ul>
  <li>Large SAT problems in CNF format: http://www.miroslav-velev.com/sat_benchmarks.html</li>
  <li>low-to-medium sized SAT problems in DIMACS CNF format: https://www.cs.ubc.ca/~hoos/SATLIB/benchm.html</li>
</ul>

<h3 id="gpu-sat-solver-implementations">GPU SAT solver implementations</h3>
<ul>
  <li>https://github.com/QuentinFiard/cuda-sat-solver - But doesn’t seem to be calling any cuda kernels at all!?</li>
  <li>https://github.com/nicolasprevot/GpuShareSat</li>
</ul>
:ET